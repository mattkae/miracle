/**
Copyright (C) 2024  Matthew Kosarek

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
**/

/*
 * AUTOGENERATED - DO NOT EDIT
 *
 * This file is generated from wlr-output-management-unstable-v1.xml by mir_wayland_generator
 */

#ifndef MIR_FRONTEND_WAYLAND_WLR_OUTPUT_MANAGEMENT_UNSTABLE_V1_XML_WRAPPER
#define MIR_FRONTEND_WAYLAND_WLR_OUTPUT_MANAGEMENT_UNSTABLE_V1_XML_WRAPPER

#include <optional>

#include "mir/fd.h"
#include <wayland-server-core.h>

#include "mir/wayland/global.h"
#include "mir/wayland/resource.h"

namespace mir
{
namespace wayland
{

    class ZwlrOutputManagerV1;
    class ZwlrOutputHeadV1;
    class ZwlrOutputModeV1;
    class ZwlrOutputConfigurationV1;
    class ZwlrOutputConfigurationHeadV1;

    class ZwlrOutputManagerV1 : public Resource
    {
    public:
        static char const constexpr* interface_name = "zwlr_output_manager_v1";

        static ZwlrOutputManagerV1* from(struct wl_resource*);

        ZwlrOutputManagerV1(struct wl_resource* resource, Version<2>);
        virtual ~ZwlrOutputManagerV1();

        void send_head_event(struct wl_resource* head) const;
        void send_done_event(uint32_t serial) const;
        void send_finished_event() const;

        void destroy_and_delete() const;

        struct Opcode
        {
            static uint32_t const head = 0;
            static uint32_t const done = 1;
            static uint32_t const finished = 2;
        };

        struct Thunks;

        static bool is_instance(wl_resource* resource);

        class Global : public wayland::Global
        {
        public:
            Global(wl_display* display, Version<2>);

            auto interface_name() const -> char const* override;

        private:
            virtual void bind(wl_resource* new_zwlr_output_manager_v1) = 0;
            friend ZwlrOutputManagerV1::Thunks;
        };

    private:
        virtual void create_configuration(struct wl_resource* id, uint32_t serial) = 0;
        virtual void stop() = 0;
    };

    class ZwlrOutputHeadV1 : public Resource
    {
    public:
        static char const constexpr* interface_name = "zwlr_output_head_v1";

        static ZwlrOutputHeadV1* from(struct wl_resource*);

        ZwlrOutputHeadV1(ZwlrOutputManagerV1 const& parent);
        virtual ~ZwlrOutputHeadV1();

        void send_name_event(std::string const& name) const;
        void send_description_event(std::string const& description) const;
        void send_physical_size_event(int32_t width, int32_t height) const;
        void send_mode_event(struct wl_resource* mode) const;
        void send_enabled_event(int32_t enabled) const;
        void send_current_mode_event(struct wl_resource* mode) const;
        void send_position_event(int32_t x, int32_t y) const;
        void send_transform_event(int32_t transform) const;
        void send_scale_event(double scale) const;
        void send_finished_event() const;
        bool version_supports_make();
        void send_make_event_if_supported(std::string const& make) const;
        void send_make_event(std::string const& make) const;
        bool version_supports_model();
        void send_model_event_if_supported(std::string const& model) const;
        void send_model_event(std::string const& model) const;
        bool version_supports_serial_number();
        void send_serial_number_event_if_supported(std::string const& serial_number) const;
        void send_serial_number_event(std::string const& serial_number) const;

        void destroy_and_delete() const;

        struct Opcode
        {
            static uint32_t const name = 0;
            static uint32_t const description = 1;
            static uint32_t const physical_size = 2;
            static uint32_t const mode = 3;
            static uint32_t const enabled = 4;
            static uint32_t const current_mode = 5;
            static uint32_t const position = 6;
            static uint32_t const transform = 7;
            static uint32_t const scale = 8;
            static uint32_t const finished = 9;
            static uint32_t const make = 10;
            static uint32_t const model = 11;
            static uint32_t const serial_number = 12;
        };

        struct Thunks;

        static bool is_instance(wl_resource* resource);

    private:
    };

    class ZwlrOutputModeV1 : public Resource
    {
    public:
        static char const constexpr* interface_name = "zwlr_output_mode_v1";

        static ZwlrOutputModeV1* from(struct wl_resource*);

        ZwlrOutputModeV1(ZwlrOutputHeadV1 const& parent);
        virtual ~ZwlrOutputModeV1();

        void send_size_event(int32_t width, int32_t height) const;
        void send_refresh_event(int32_t refresh) const;
        void send_preferred_event() const;
        void send_finished_event() const;

        void destroy_and_delete() const;

        struct Opcode
        {
            static uint32_t const size = 0;
            static uint32_t const refresh = 1;
            static uint32_t const preferred = 2;
            static uint32_t const finished = 3;
        };

        struct Thunks;

        static bool is_instance(wl_resource* resource);

    private:
    };

    class ZwlrOutputConfigurationV1 : public Resource
    {
    public:
        static char const constexpr* interface_name = "zwlr_output_configuration_v1";

        static ZwlrOutputConfigurationV1* from(struct wl_resource*);

        ZwlrOutputConfigurationV1(struct wl_resource* resource, Version<2>);
        virtual ~ZwlrOutputConfigurationV1();

        void send_succeeded_event() const;
        void send_failed_event() const;
        void send_cancelled_event() const;

        struct Error
        {
            static uint32_t const already_configured_head = 1;
            static uint32_t const unconfigured_head = 2;
            static uint32_t const already_used = 3;
        };

        struct Opcode
        {
            static uint32_t const succeeded = 0;
            static uint32_t const failed = 1;
            static uint32_t const cancelled = 2;
        };

        struct Thunks;

        static bool is_instance(wl_resource* resource);

    private:
        virtual void enable_head(struct wl_resource* id, struct wl_resource* head) = 0;
        virtual void disable_head(struct wl_resource* head) = 0;
        virtual void apply() = 0;
        virtual void test() = 0;
        virtual void destroy() { }
    };

    class ZwlrOutputConfigurationHeadV1 : public Resource
    {
    public:
        static char const constexpr* interface_name = "zwlr_output_configuration_head_v1";

        static ZwlrOutputConfigurationHeadV1* from(struct wl_resource*);

        ZwlrOutputConfigurationHeadV1(struct wl_resource* resource, Version<2>);
        virtual ~ZwlrOutputConfigurationHeadV1();

        void destroy_and_delete() const;

        struct Error
        {
            static uint32_t const already_set = 1;
            static uint32_t const invalid_mode = 2;
            static uint32_t const invalid_custom_mode = 3;
            static uint32_t const invalid_transform = 4;
            static uint32_t const invalid_scale = 5;
        };

        struct Thunks;

        static bool is_instance(wl_resource* resource);

    private:
        virtual void set_mode(struct wl_resource* mode) = 0;
        virtual void set_custom_mode(int32_t width, int32_t height, int32_t refresh) = 0;
        virtual void set_position(int32_t x, int32_t y) = 0;
        virtual void set_transform(int32_t transform) = 0;
        virtual void set_scale(double scale) = 0;
    };

}
}

#endif // MIR_FRONTEND_WAYLAND_WLR_OUTPUT_MANAGEMENT_UNSTABLE_V1_XML_WRAPPER
